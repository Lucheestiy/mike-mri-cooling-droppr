<!-- VERSION: 1.4.11 - Auto shows active source; iOS Auto=HD -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Video Player</title>
    <style>
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            background: #000;
            color: #fff;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        }

        .topbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: max(0.75rem, env(safe-area-inset-top, 0px)) 0.75rem 0.75rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.85), rgba(0,0,0,0));
            z-index: 10;
        }

        .left {
            display: flex;
            gap: 0.75rem;
            align-items: center;
            min-width: 0;
            flex: 1;
        }

        .title {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .title .name {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60vw;
        }

        .title .sub {
            font-size: 0.85rem;
            opacity: 0.75;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 60vw;
        }

        .btn {
            appearance: none;
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.08);
            color: #fff;
            padding: 0.55rem 0.8rem;
            border-radius: 12px;
            text-decoration: none;
            cursor: pointer;
            font-weight: 600;
            white-space: nowrap;
        }

        .btn:active { transform: translateY(1px); }

        .actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        @media (max-width: 600px) {
            .actions .btn.secondary { display: none; }
            .title .name, .title .sub { max-width: 50vw; }
        }

	        .player {
	            height: 100%;
	            display: flex;
	            align-items: center;
	            justify-content: center;
	            padding: 0;
	        }

	        .statusbar {
	            position: fixed;
	            left: 0;
	            right: 0;
	            bottom: 0;
	            padding: 0.6rem 0.75rem max(0.6rem, env(safe-area-inset-bottom, 0px));
	            background: linear-gradient(to top, rgba(0,0,0,0.85), rgba(0,0,0,0));
	            z-index: 10;
	            pointer-events: none;
	        }

	        .statusbar .row {
	            display: flex;
	            gap: 0.75rem;
	            align-items: center;
	            justify-content: space-between;
	            font-size: 0.85rem;
	            opacity: 0.92;
	        }

	        .statusbar .lefttext {
	            min-width: 0;
	            overflow: hidden;
	            white-space: nowrap;
	            text-overflow: ellipsis;
	        }

	        .statusbar .righttext {
	            white-space: nowrap;
	            opacity: 0.9;
	        }

	        .statusbar .bar {
	            margin-top: 0.4rem;
	            height: 6px;
	            border-radius: 999px;
	            background: rgba(255,255,255,0.12);
	            overflow: hidden;
	        }

	        .statusbar .fill {
	            height: 100%;
	            width: 0%;
	            background: rgba(255,255,255,0.65);
	        }

	        video {
	            width: 100%;
	            height: 100%;
	            max-height: 100vh;
            background: #000;
        }

        .error {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            text-align: center;
            background: rgba(0,0,0,0.9);
            z-index: 20;
        }

        .error.show { display: flex; }
        .error h2 { margin: 0 0 0.5rem; }
        .error p { margin: 0.25rem 0; opacity: 0.85; }
    </style>
</head>
<body>
    <div class="topbar">
        <div class="left">
            <a id="backLink" class="btn" href="#">← Back</a>
            <div class="title">
                <div id="fileName" class="name">Video</div>
                <div id="fileSub" class="sub"></div>
            </div>
        </div>
        <div class="actions">
            <a id="downloadLink" class="btn secondary" href="#" download>⬇ Download</a>
            <a id="openLink" class="btn secondary" href="#" target="_blank" rel="noopener">↗ Open</a>
            <button id="qualityBtn" class="btn" type="button" title="Quality mode">Auto</button>
            <button id="reloadBtn" class="btn" type="button">⟳ Reload</button>
        </div>
    </div>

	    <div class="player">
	        <video id="video" controls playsinline preload="metadata"></video>
	    </div>

	    <div id="statusBar" class="statusbar" aria-live="polite">
	        <div class="row">
	            <div id="bufferText" class="lefttext">Loading…</div>
	            <div id="timeText" class="righttext"></div>
	        </div>
	        <div class="bar"><div id="bufferFill" class="fill"></div></div>
	    </div>

	    <div id="error" class="error" role="dialog" aria-modal="true" aria-label="Error">
	        <div>
	            <h2 id="errorTitle">Could not load video</h2>
	            <p id="errorMessage">Please go back and try again.</p>
        </div>
    </div>

    <script>
    (function () {
        'use strict';

        function encodePath(p) {
            return String(p || '').split('/').map(s => encodeURIComponent(s)).join('/');
        }

        function safeRelPath(value) {
            if (value == null) return null;
            value = String(value);
            if (value.startsWith('/') || value.startsWith('\\')) return null;
            if (value.includes('\\')) return null;
            const parts = value.split('/').filter(Boolean);
            if (!parts.length) return null;
            if (parts.some(p => p === '..')) return null;
            return parts.join('/');
        }

        function showError(title, message) {
            document.getElementById('errorTitle').textContent = title || 'Error';
            document.getElementById('errorMessage').textContent = message || '';
            document.getElementById('error').classList.add('show');
        }

        const params = new URLSearchParams(window.location.search);
        const share = (params.get('share') || '').trim();
        const file = (params.get('file') || '').trim();

        if (!/^[A-Za-z0-9_-]{1,64}$/.test(share)) {
            showError('Invalid link', 'Missing or invalid share hash.');
            return;
        }

        const safeFile = safeRelPath(file);
        if (!safeFile) {
            showError('Invalid link', 'Missing or invalid file path.');
            return;
        }

        const fileName = safeFile.split('/').pop() || safeFile;
        document.title = fileName + ' - Droppr';
        document.getElementById('fileName').textContent = fileName;
        const fileSubEl = document.getElementById('fileSub');
        fileSubEl.textContent = share;

        const sourcesApiUrl = `/api/share/${share}/video-sources/${encodePath(safeFile)}`;
        const originalInlineUrlDefault = `/api/public/dl/${share}/${encodePath(safeFile)}?inline=true`;
        const downloadUrl = `/api/share/${share}/file/${encodePath(safeFile)}?download=1`;
        const backUrl = `/gallery/${share}`;

        const video = document.getElementById('video');
        const bufferText = document.getElementById('bufferText');
        const timeText = document.getElementById('timeText');
        const bufferFill = document.getElementById('bufferFill');
        const backLink = document.getElementById('backLink');
        const downloadLink = document.getElementById('downloadLink');
        const openLink = document.getElementById('openLink');
        const qualityBtn = document.getElementById('qualityBtn');
        const reloadBtn = document.getElementById('reloadBtn');

        backLink.href = backUrl;
        downloadLink.href = downloadUrl;
        downloadLink.download = fileName;
        openLink.href = originalInlineUrlDefault;

        const QUALITY_MODES = ['auto', 'hd', 'fast'];
        const QUALITY_LABEL = { auto: 'Auto', hd: 'HD', fast: 'Fast' };

        let qualityMode = (params.get('quality') || 'auto').trim().toLowerCase();
        if (!QUALITY_MODES.includes(qualityMode)) qualityMode = 'auto';

        const sources = {
            original: { url: originalInlineUrlDefault, size: null },
            fast: { url: null, ready: false, size: null },
            hd: { url: null, ready: false, size: null },
        };

        let activeSource = null; // 'fast' | 'hd' | 'original'
        let switchInProgress = false;
        let stallTimer = null;
        let statusTimer = null;
        let sourceLoadStartedAt = 0;
        let sourcesPollTimer = null;
        let sourcesPollStartedAt = 0;
        let sourcesPollInFlight = false;
        let lastHdFailureAt = 0;
        let hdFailureCount = 0;
        let hdSuppressedUntil = 0;
        let hdAutoDisabled = false;
        let hdStableTimer = null;
        let hdUpgradeTimer = null;
        let hdPrepareInFlight = false;
        let fastPrepareInFlight = false;

        let interactionTimer = null;
        let lastInteractionAt = 0;
        let isInteracting = false;

        const AUTO_STALL_FALLBACK_MS = 3500;
        const AUTO_STALL_FALLBACK_INITIAL_MS = 8000;
        const HD_FAILURE_BASE_COOLDOWN_MS = 15000;
        const HD_FAILURE_MAX_COOLDOWN_MS = 5 * 60 * 1000;
        const HD_FAILURE_DISABLE_AFTER = 3;
        const HD_STABLE_RESET_MS = 5000;
        const AUTO_HD_UPGRADE_DELAY_MS = 1200;
        const SOURCES_POLL_MS = 2000;
        const SOURCES_POLL_MAX_MS = 10 * 60 * 1000;
        const INTERACTION_IDLE_MS = 800;

        const UA = navigator.userAgent || '';
        const IS_IOS =
            /iPad|iPhone|iPod/i.test(UA) ||
            (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        // iOS/WebKit can fail to resume playback after programmatic src swaps (start/stop loops).
        // In Auto mode on iOS, start in HD and avoid automatic source switching.
        const AUTO_SWITCH_ENABLED = !IS_IOS;

        function formatTime(seconds) {
            if (!Number.isFinite(seconds) || seconds < 0) return '--:--';
            const s = Math.floor(seconds);
            const h = Math.floor(s / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;
            if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
            return `${m}:${String(sec).padStart(2, '0')}`;
        }

        function formatBytes(bytes) {
            if (!Number.isFinite(bytes) || bytes < 0) return '';
            const units = ['B', 'KB', 'MB', 'GB', 'TB'];
            let v = bytes;
            let i = 0;
            while (v >= 1024 && i < units.length - 1) {
                v /= 1024;
                i++;
            }
            const digits = v >= 100 || i === 0 ? 0 : (v >= 10 ? 1 : 2);
            return `${v.toFixed(digits)} ${units[i]}`;
        }

        function clearHdStableTimer() {
            if (!hdStableTimer) return;
            clearTimeout(hdStableTimer);
            hdStableTimer = null;
        }

        function computeHdCooldownMs() {
            const exp = Math.max(0, hdFailureCount - 1);
            const ms = HD_FAILURE_BASE_COOLDOWN_MS * Math.pow(2, exp);
            return Math.min(HD_FAILURE_MAX_COOLDOWN_MS, ms);
        }

        function noteHdFailure() {
            lastHdFailureAt = Date.now();
            hdFailureCount = Math.min(10, hdFailureCount + 1);
            hdSuppressedUntil = lastHdFailureAt + computeHdCooldownMs();
            hdAutoDisabled = hdFailureCount >= HD_FAILURE_DISABLE_AFTER;
            clearHdStableTimer();
            if (hdUpgradeTimer) {
                clearTimeout(hdUpgradeTimer);
                hdUpgradeTimer = null;
            }
        }

        function noteHdStable() {
            hdFailureCount = 0;
            hdSuppressedUntil = 0;
            hdAutoDisabled = false;
        }

        function startHdStableTimer() {
            clearHdStableTimer();
            hdStableTimer = setTimeout(() => {
                if (activeSource !== 'hd') return;
                if (video.paused) return;
                if (video.seeking) return;
                if (video.error) return;
                noteHdStable();
                updateStatusUI();
            }, HD_STABLE_RESET_MS);
        }

        function scheduleHdUpgrade(delayMs) {
            if (qualityMode !== 'auto') return;
            if (!AUTO_SWITCH_ENABLED) return;
            if (hdAutoDisabled) return;
            if (hdUpgradeTimer) clearTimeout(hdUpgradeTimer);
            hdUpgradeTimer = setTimeout(() => {
                hdUpgradeTimer = null;
                maybeUpgradeToHd();
            }, Math.max(0, delayMs || 0));
        }

        function sourceLabel(sourceType) {
            if (sourceType === 'hd') return 'HD';
            if (sourceType === 'fast') return 'Fast';
            return 'Original';
        }

        function setOpenLinkForSource(sourceType) {
            const src = sources[sourceType] && sources[sourceType].url;
            openLink.href = src || sources.original.url || originalInlineUrlDefault;
        }

        function updateQualityUI() {
            const modeLabel = QUALITY_LABEL[qualityMode] || 'Auto';
            const srcLabel = activeSource ? sourceLabel(activeSource) : '';
            qualityBtn.textContent = (qualityMode === 'auto' && srcLabel) ? `${modeLabel} (${srcLabel})` : modeLabel;

            const sizeBytes =
                (activeSource && sources[activeSource] && sources[activeSource].size) ||
                sources.original.size ||
                null;

            let sub = `${share} • ${modeLabel}`;
            if (srcLabel) sub += `: ${srcLabel}`;
            if (sizeBytes) sub += ` • ${formatBytes(sizeBytes)}`;
            fileSubEl.textContent = sub;

            setOpenLinkForSource(activeSource || 'original');
        }

        function getStateLabel() {
            if (video.error) return 'Error';
            if (video.seeking) return 'Seeking';

            const elapsed = Date.now() - (sourceLoadStartedAt || 0);
            if (video.readyState === 0 && elapsed > 2000) {
                if (activeSource === 'fast') return 'Loading fast preview…';
                if (activeSource === 'hd') return 'Loading HD…';
                return 'Loading original…';
            }

            if (!video.paused && video.readyState < 3) return 'Buffering';
            if (!video.paused) return 'Playing';
            if (video.currentTime > 0) return 'Paused';
            if (video.readyState >= 2) return 'Ready';
            return 'Loading';
        }

        function getBufferedInfo() {
            const dur = Number.isFinite(video.duration) ? video.duration : null;
            const ct = Number.isFinite(video.currentTime) ? video.currentTime : 0;

            const ranges = [];
            try {
                const b = video.buffered;
                for (let i = 0; i < b.length; i++) {
                    const start = b.start(i);
                    const end = b.end(i);
                    if (Number.isFinite(start) && Number.isFinite(end) && end > start) ranges.push([start, end]);
                }
            } catch (e) {}

            let total = 0;
            for (const [s, e] of ranges) total += (e - s);

            let ahead = 0;
            for (const [s, e] of ranges) {
                if (ct >= s && ct <= e) {
                    ahead = Math.max(0, e - ct);
                    break;
                }
            }

            const pct = (dur && dur > 0) ? Math.max(0, Math.min(1, total / dur)) : null;
            return { dur, ct, pct, ahead };
        }

        function updateStatusUI() {
            const state = getStateLabel();
            const info = getBufferedInfo();

            timeText.textContent = info.dur ? `${formatTime(info.ct)} / ${formatTime(info.dur)}` : formatTime(info.ct);

            const modeLabel = QUALITY_LABEL[qualityMode] || 'Auto';
            const srcLabel = activeSource ? sourceLabel(activeSource) : '';
            let text = srcLabel ? `${modeLabel} • ${srcLabel} • ${state}` : `${modeLabel} • ${state}`;

            if (info.pct != null) {
                const pctText = Math.round(info.pct * 100);
                text += ` • Buffered ${pctText}%`;
                if (info.ahead > 0) text += ` • Ahead ${Math.round(info.ahead)}s`;
                bufferFill.style.width = `${Math.max(0, Math.min(100, info.pct * 100)).toFixed(1)}%`;
            } else {
                bufferFill.style.width = '0%';
            }

            if ((qualityMode === 'auto' || qualityMode === 'hd') && !sources.hd.ready && hdPrepareInFlight) {
                text += ' • Preparing HD…';
            }
            if ((qualityMode === 'auto' || qualityMode === 'fast') && !sources.fast.ready && fastPrepareInFlight) {
                text += ' • Preparing Fast…';
            }

            if (qualityMode === 'auto' && !AUTO_SWITCH_ENABLED) {
                text += ' • iOS: Auto=HD';
            }

            if (qualityMode === 'auto' && sources.hd.ready && activeSource !== 'hd') {
                if (hdAutoDisabled) {
                    text += ' • HD off (tap HD)';
                } else if (hdSuppressedUntil && Date.now() < hdSuppressedUntil) {
                    const secs = Math.max(1, Math.ceil((hdSuppressedUntil - Date.now()) / 1000));
                    text += ` • HD retry in ${secs}s`;
                }
            }

            bufferText.textContent = text;
        }

        function startStatusTimer() {
            if (statusTimer) return;
            statusTimer = setInterval(updateStatusUI, 500);
        }

        function stopStatusTimer() {
            if (!statusTimer) return;
            clearInterval(statusTimer);
            statusTimer = null;
        }

        function appendCacheBust(url, cacheBust) {
            if (!cacheBust) return url;
            const sep = url.includes('?') ? '&' : '?';
            return url + sep + 'v=' + Date.now();
        }

        function getUrlForSource(sourceType, cacheBust) {
            const base = sources[sourceType] && sources[sourceType].url;
            if (!base) return null;
            return appendCacheBust(base, cacheBust);
        }

        function pickPlayableSource(desired, opts) {
            const options = opts || {};
            const avoid = options.avoid ? String(options.avoid) : '';

            if (desired === 'hd') {
                if (avoid !== 'hd' && sources.hd.ready) return 'hd';
                if (avoid !== 'fast' && sources.fast.ready) return 'fast';
                return 'original';
            }

            if (desired === 'fast') {
                if (avoid !== 'fast' && sources.fast.ready) return 'fast';
                if (avoid !== 'hd' && sources.hd.ready) return 'hd';
                return 'original';
            }

            if (avoid !== 'hd' && sources.hd.ready) return 'hd';
            if (avoid !== 'fast' && sources.fast.ready) return 'fast';
            return 'original';
        }

        function desiredForCurrentMode() {
            if (qualityMode === 'fast') return 'fast';
            if (qualityMode === 'hd') return 'hd';
            if (!AUTO_SWITCH_ENABLED) return 'hd';
            if (hdAutoDisabled) return 'fast';
            if (video.paused) return 'fast';
            if (isInteracting || video.seeking) return 'fast';
            return 'hd';
        }

        function noteInteraction(opts) {
            const options = opts || {};
            const allowFastSwitch = options.allowFastSwitch !== false;

            lastInteractionAt = Date.now();
            if (!isInteracting) {
                isInteracting = true;
                if (hdUpgradeTimer) {
                    clearTimeout(hdUpgradeTimer);
                    hdUpgradeTimer = null;
                }
                if (qualityMode === 'auto') {
                    if (!sources.fast.ready && !fastPrepareInFlight) ensurePrepared(['fast']);
                    if (AUTO_SWITCH_ENABLED && allowFastSwitch && sources.fast.ready && activeSource !== 'fast' && !switchInProgress) {
                        setSource('fast', { time: video.currentTime, shouldPlay: !video.paused });
                    }
                }
                updateStatusUI();
            }

            if (interactionTimer) clearTimeout(interactionTimer);
            interactionTimer = setTimeout(() => {
                if (Date.now() - lastInteractionAt < INTERACTION_IDLE_MS) return;
                interactionTimer = null;
                if (!isInteracting) return;
                isInteracting = false;
                updateStatusUI();

                if (qualityMode === 'auto' && !video.paused) {
                    if (
                        AUTO_SWITCH_ENABLED &&
                        !hdAutoDisabled &&
                        !sources.hd.ready &&
                        !hdPrepareInFlight
                    ) {
                        ensurePrepared(['hd']);
                    }
                    scheduleHdUpgrade(AUTO_HD_UPGRADE_DELAY_MS);
                }
            }, INTERACTION_IDLE_MS + 25);
        }

        function clearTimers() {
            if (stallTimer) clearTimeout(stallTimer);
            stallTimer = null;
        }

        function setSource(sourceType, opts) {
            const options = opts || {};
            const targetTime = Number.isFinite(options.time) ? Math.max(0, options.time) : null;
            const shouldPlay = !!options.shouldPlay;
            const cacheBust = !!options.cacheBust;

            const src = getUrlForSource(sourceType, cacheBust);
            if (!src) {
                showError('Could not load video', 'Missing source URL.');
                return;
            }

            switchInProgress = true;
            clearTimers();
            activeSource = sourceType;
            sourceLoadStartedAt = Date.now();
            updateQualityUI();

            const currentTimeBefore = video.currentTime || 0;

            function done() {
                switchInProgress = false;
                updateQualityUI();
            }

            video.pause();
            video.removeAttribute('src');
            video.load();
            updateStatusUI();

            video.addEventListener(
                'loadedmetadata',
                () => {
                    try {
                        if (targetTime != null) {
                            const dur = Number.isFinite(video.duration) ? video.duration : null;
                            video.currentTime = dur ? Math.min(targetTime, Math.max(0, dur - 0.25)) : targetTime;
                        }
                    } catch (e) {}

                    if (shouldPlay) {
                        video.play().catch(() => {});
                    }
                    done();
                },
                { once: true }
            );

            video.addEventListener(
                'error',
                () => {
                    done();
                    if (qualityMode === 'auto' && sourceType === 'hd') {
                        noteHdFailure();
                        const t = Number.isFinite(targetTime) ? targetTime : currentTimeBefore;
                        setSource(pickPlayableSource('fast', { avoid: 'hd' }), { time: t, shouldPlay });
                    }
                },
                { once: true }
            );

            video.src = src;
            video.load();
            startStatusTimer();
            updateStatusUI();
        }

        async function fetchSources(options) {
            const opts = options || {};
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 8000);
            try {
                const url = sourcesApiUrl + (sourcesApiUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
                let resp;
                if (opts.prepareTargets && opts.prepareTargets.length) {
                    resp = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prepare: opts.prepareTargets }),
                        signal: controller.signal,
                        cache: 'no-store',
                    });
                } else {
                    resp = await fetch(url, { signal: controller.signal, cache: 'no-store' });
                }
                if (!resp.ok) return null;
                const data = await resp.json();
                return data;
            } catch (e) {
                return null;
            } finally {
                clearTimeout(timeout);
            }
        }

        function applySourcesData(data) {
            if (!data || typeof data !== 'object') return;

            if (data.original && typeof data.original === 'object') {
                if (typeof data.original.url === 'string' && data.original.url) sources.original.url = data.original.url;
                const s = Number(data.original.size);
                if (Number.isFinite(s) && s > 0) sources.original.size = Math.floor(s);
            }

            if (data.fast && typeof data.fast === 'object') {
                if (typeof data.fast.url === 'string' && data.fast.url) sources.fast.url = data.fast.url;
                if (typeof data.fast.ready === 'boolean') sources.fast.ready = data.fast.ready;
                const s = Number(data.fast.size);
                sources.fast.size = Number.isFinite(s) && s > 0 ? Math.floor(s) : null;
            }

            if (data.hd && typeof data.hd === 'object') {
                if (typeof data.hd.url === 'string' && data.hd.url) sources.hd.url = data.hd.url;
                if (typeof data.hd.ready === 'boolean') sources.hd.ready = data.hd.ready;
                const s = Number(data.hd.size);
                sources.hd.size = Number.isFinite(s) && s > 0 ? Math.floor(s) : null;
            }

            updateQualityUI();
            updateStatusUI();
        }

        function startSourcesPoller() {
            if (sourcesPollTimer) return;
            sourcesPollStartedAt = Date.now();
            sourcesPollTimer = setInterval(async () => {
                if (sourcesPollStartedAt && (Date.now() - sourcesPollStartedAt) > SOURCES_POLL_MAX_MS) {
                    clearInterval(sourcesPollTimer);
                    sourcesPollTimer = null;
                    fastPrepareInFlight = false;
                    hdPrepareInFlight = false;
                    updateStatusUI();
                    return;
                }
                if (sourcesPollInFlight) return;
                sourcesPollInFlight = true;
                try {
                    const beforeFast = sources.fast.ready;
                    const beforeHd = sources.hd.ready;
                    const data = await fetchSources();
                    if (data) applySourcesData(data);
                    const afterFast = sources.fast.ready;
                    const afterHd = sources.hd.ready;

                    if (!beforeFast && afterFast) {
                        fastPrepareInFlight = false;
                        updateStatusUI();

                        const shouldPlay = !video.paused;
                        if (!switchInProgress) {
                            if (qualityMode === 'fast' && activeSource !== 'fast') {
                                setSource('fast', { time: video.currentTime, shouldPlay });
                            } else if (qualityMode === 'auto' && AUTO_SWITCH_ENABLED) {
                                if ((isInteracting || video.seeking || video.paused) && activeSource !== 'fast') {
                                    setSource('fast', { time: video.currentTime, shouldPlay });
                                }
                            }
                        }
                    }

                    if (!beforeHd && afterHd) {
                        hdPrepareInFlight = false;
                        updateStatusUI();
                        if (switchInProgress) {
                            // wait for current switch to finish
                        } else if (qualityMode === 'hd') {
                            const attemptSwitch = () => {
                                if (switchInProgress) return;
                                if (qualityMode !== 'hd' || activeSource === 'hd') return;
                                if (isInteracting || video.seeking) {
                                    setTimeout(attemptSwitch, 500);
                                    return;
                                }
                                setSource('hd', { time: video.currentTime, shouldPlay: !video.paused });
                            };
                            attemptSwitch();
                        } else if (qualityMode === 'auto' && AUTO_SWITCH_ENABLED && !video.paused) {
                            scheduleHdUpgrade(AUTO_HD_UPGRADE_DELAY_MS);
                        }
                    }

                    if (sources.fast.ready) fastPrepareInFlight = false;
                    if (sources.hd.ready) hdPrepareInFlight = false;

                    if (!fastPrepareInFlight && !hdPrepareInFlight) {
                        clearInterval(sourcesPollTimer);
                        sourcesPollTimer = null;
                    }
                } finally {
                    sourcesPollInFlight = false;
                }
            }, SOURCES_POLL_MS);
        }

        async function ensurePrepared(targets) {
            if (!targets || !targets.length) return;
            if (targets.includes('fast')) fastPrepareInFlight = true;
            if (targets.includes('hd')) hdPrepareInFlight = true;
            updateStatusUI();
            const data = await fetchSources({ prepareTargets: targets });
            if (data) applySourcesData(data);
            startSourcesPoller();
        }

        function scheduleStallFallback() {
            if (qualityMode !== 'auto') return;
            if (!AUTO_SWITCH_ENABLED) return;
            if (activeSource !== 'hd') return;
            if (switchInProgress) return;
            if (video.paused) return;

            if (stallTimer) clearTimeout(stallTimer);
            const elapsed = Date.now() - (sourceLoadStartedAt || 0);
            const delay = elapsed < 6000 ? AUTO_STALL_FALLBACK_INITIAL_MS : AUTO_STALL_FALLBACK_MS;
            stallTimer = setTimeout(() => {
                if (qualityMode !== 'auto') return;
                if (activeSource !== 'hd') return;
                if (switchInProgress) return;
                if (video.paused) return;

                noteHdFailure();
                setSource(pickPlayableSource('fast', { avoid: 'hd' }), { time: video.currentTime, shouldPlay: true });
            }, delay);
        }

        function maybeUpgradeToHd() {
            if (qualityMode !== 'auto') return;
            if (!AUTO_SWITCH_ENABLED) return;
            if (hdAutoDisabled) return;
            if (isInteracting) return;
            if (video.seeking) return;
            if (activeSource === 'hd') return;
            if (!sources.hd.ready) return;
            if (hdSuppressedUntil && Date.now() < hdSuppressedUntil) return;
            if (switchInProgress) return;

            const shouldPlay = !video.paused;
            if (!shouldPlay) return;
            setSource('hd', { time: video.currentTime, shouldPlay: true });
        }

        function loadInitial() {
            startStatusTimer();
            updateStatusUI();

            fetchSources().then((data) => {
                if (data) applySourcesData(data);

                if (qualityMode === 'auto' && !sources.fast.ready) {
                    ensurePrepared(['fast']);
                } else if (qualityMode === 'hd' && !sources.hd.ready) {
                    ensurePrepared(['hd']);
                } else if (qualityMode === 'fast' && !sources.fast.ready) {
                    ensurePrepared(['fast']);
                }

                const desired = desiredForCurrentMode();
                setSource(pickPlayableSource(desired), { time: 0, shouldPlay: false });
            });
        }

        function cycleQualityMode() {
            const idx = QUALITY_MODES.indexOf(qualityMode);
            const next = QUALITY_MODES[(idx + 1) % QUALITY_MODES.length];
            qualityMode = next;

            const t = video.currentTime;
            const shouldPlay = !video.paused;
            const desired = desiredForCurrentMode();

            if ((qualityMode === 'auto' || qualityMode === 'hd') && !sources.hd.ready) ensurePrepared(['hd']);
            if (qualityMode === 'auto' && !sources.fast.ready) ensurePrepared(['fast']);
            if (qualityMode === 'fast' && !sources.fast.ready) ensurePrepared(['fast']);

            setSource(pickPlayableSource(desired), { time: t, shouldPlay });
        }

        qualityBtn.onclick = () => cycleQualityMode();

        reloadBtn.onclick = () => {
            const t = video.currentTime;
            const shouldPlay = !video.paused;
            setSource(activeSource || pickPlayableSource(desiredForCurrentMode()), {
                time: t,
                shouldPlay,
                cacheBust: true,
            });
        };

        video.addEventListener('play', () => {
            if (qualityMode === 'auto' && !sources.fast.ready && !fastPrepareInFlight) ensurePrepared(['fast']);
            if ((qualityMode === 'hd' || (qualityMode === 'auto' && !hdAutoDisabled)) && !sources.hd.ready && !hdPrepareInFlight) {
                ensurePrepared(['hd']);
            }
            if (qualityMode === 'fast' && !sources.fast.ready && !fastPrepareInFlight) ensurePrepared(['fast']);
        });

        video.addEventListener('playing', () => {
            if (stallTimer) clearTimeout(stallTimer);
            stallTimer = null;
            if (activeSource === 'hd') startHdStableTimer();
            if (qualityMode === 'auto') scheduleHdUpgrade(AUTO_HD_UPGRADE_DELAY_MS);
            updateStatusUI();
        });
        video.addEventListener('seeking', () => { clearHdStableTimer(); if (!switchInProgress) noteInteraction(); updateStatusUI(); });
        video.addEventListener('seeked', () => { noteInteraction({ allowFastSwitch: false }); updateStatusUI(); });
        video.addEventListener('waiting', () => { clearHdStableTimer(); scheduleStallFallback(); updateStatusUI(); });
        video.addEventListener('stalled', () => { clearHdStableTimer(); scheduleStallFallback(); updateStatusUI(); });
        video.addEventListener('progress', updateStatusUI);
        video.addEventListener('timeupdate', updateStatusUI);
        video.addEventListener('pause', () => { clearHdStableTimer(); updateStatusUI(); });

        video.addEventListener('error', () => {
            clearHdStableTimer();
            if (qualityMode === 'auto' && activeSource === 'hd') return;
            showError('Could not load video', 'Try Reload. If it keeps failing, go back to the gallery.');
        });

        window.addEventListener('beforeunload', () => stopStatusTimer());

        loadInitial();

    })();
    </script>
</body>
</html>
